\documentclass{llncs}

\usepackage{tabularx}
\newcolumntype{Y}{>{\centering\arraybackslash}X}

% Math
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

% Code listing
\usepackage{minted}
\usemintedstyle{tango}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{CodeBg}{gray!90}
\usepackage{color, colortbl}
\definecolor{Gray}{rgb}{0.9,0.9,0.9}
\definecolor{White}{rgb}{1,1,1}
\definecolor{bblue}{HTML}{1D577A}
\definecolor{rred}{HTML}{C03425}
\definecolor{ggreen}{HTML}{8BB523}
\definecolor{ppurple}{HTML}{6B1B7F}
\definecolor{pblack}{HTML}{000000}
\definecolor{pyellow}{HTML}{C0B225}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour,citecolor=linkcolour}

% Graphs
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{trees}
\usetikzlibrary{positioning}
\usepackage{pgfplots}

% Graphics
\usepackage{graphics}
\graphicspath{{img/}} % Location of the graphics files

% Macros
\newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand{\w}[1]{\textit{"#1"}}
\newcommand\s{\textsc}
\newcommand{\Order}[5]{
	\[
	\mathcal{#1}_{#5}\llbracket #2 \leftarrow #3 \mid \{ #4 \} \rrbracket.
	\]
}
\newcommand{\Orderr}[5]{
	\mathcal{#1}_{#5}\llbracket #2 \leftarrow #3 \mid \{ #4 \} \rrbracket.
}
\newcommand{\Orderrr}[5]{
	\mathcal{#1}_{#5}\llbracket #2 \leftarrow #3 \mid \{ #4 \} \rrbracket
}
\newcommand{\Ord}[4]{\Order{O}{#1}{#2}{#3}{#4}}
\newcommand{\Or}[4]{\Orderr{O}{#1}{#2}{#3}{#4}}
\newcommand{\Orr}[4]{\Orderrr{O}{#1}{#2}{#3}{#4}}
\newcommand{\Con}[4]{\Order{C}{#1}{#2}{#3}{#4}}
\newcommand\ctr\centering

\title{$D^3$ as a 2-MCFL}

\begin{document}
\author{Konstantinos Kogkalidis \and Orestis Melkonian}
\institute{
  University of Utrecht, The Netherlands \\
  \email{\{k.kogkalidis,o.melkonian\}@uu.nl}
}

\maketitle
\begin{abstract}
We discuss the open problem of parsing the Dyck language of 3 symbols, $D^3$, using a 2-Multiple Context-Free Grammar. We tackle this problem by implementing a number of novel meta-grammatical techniques and present the associated software packages we developed.

\keywords{Dyck Language; Multiple context-free grammars (MCFG)}
\end{abstract}

\section{Introduction}\label{sec1}
Multidimensional Dyck languages\cite{moortgat} generalize the well-known pattern of well-bracketed pairs of parentheses to k-symbol alphabets. Our goal in this paper is to study the 3-dimensional Dyck language $D^3$, and the question of whether this is a 2-dimensional multiple context-free language, 2-MCFL.

For brevity's sake, this section only serves as a brief introductory guide towards relevant papers, where the interested reader will find definitions, properties and various correspondences of the problem. 

\subsection{Preliminaries}
We use $D^3$ to refer to the Dyck language over the lexicographically ordered alphabet $a < b < c$, which generalizes well-bracketed parentheses over three symbols. Denoting with $\#x(w)$ the number of occurrences of symbol $x$ within word $w$, any word in $D^3$ satisfies the following conditions:
\begin{itemize}
\item[(D1)] $ \#a(w) = \#b(w) = \#c(w) $
\item[(D2)] $ \#a(v) \geq \#b(v) \geq \#c(v),\ \forall v \in \textit{PrefixOf}(w)$
\end{itemize}
Eliding the second condition (D2), we get the $MIX$ language, which represents free word order over the same alphabet.
$MIX$ has already been proven expressible by a 2-MCFG\cite{salvati}; the class of multiple context-free grammars that operate on pairs of strings\cite{gotzmann}.

\subsection{Motivation}

\paragraph{\textbf{Static Analysis}}
Interestingly, the 2-symbol Dyck language is used in the \textit{static analysis} of programming languages, where a large number of analyses are formulated as \textit{language-reachability} problems\cite{reps}.

For instance, when considering interprocedural calls as part of the source language, high precision can only be achieved by examining only control-flow paths that respect the fact that a procedure call always returns to the site of its current caller\cite{reps2}. By associating the program point \textit{before} a procedure call $f_k$ with $(_k$, and the one \textit{after} the call with $)_k$, the validity problem is reduced to recognizing $D^2$ words. 

Alas, the 2-dimensional case cannot accommodate richer control-flow structures, such as exception handling via \texttt{try/catch} and Python generators via the \texttt{yield} keyword. To achieve this, one must lift the Dyck-reachability problem to a higher dimension which, given the computational cost that context-sensitive parsing induces, is currently prohibited. If $D^3$ is indeed a 2-MCFL, parsing it would become computationally attainable for these purposes and eventually allow scalable analysis for non-standard control-flow mechanisms by exploiting the specific structure of analysed programs, as has been recently done in the 2-dimensional case\cite{andreas}.

Last but not least, future research directions will open up in a multitude of analyses that are currently restrained to two dimensions, such as \textit{program slicing}, \textit{flow-insensitive points-to analysis} and \textit{shape approximation}\cite{reps}.

\paragraph{\textbf{Linguistics}}
For the characterization of natural language grammars, the extreme degree of ’scrambling’ permitted by the $MIX$ language may be considered overly expressive\cite{kanazawa}.

On the other hand, the prefix condition of $D^3$ is more suggestive of free word order still respecting certain linear order constraints, as found in natural languages. Hence, it is reasonable to examine whether $D^3$ can also be modelled by a 2-MCFG. Such an endeavour proved quite challenging, necessitating careful study of correspondences with other mathematical constructs.

\subsection{Correspondences}
\paragraph{\textbf{Young Tableaux}}
A standard Young Tableau is defined as an assortment of $n$ boxes into a ragged (or jagged, i.e. non-rectangular) matrix containing the integers $1$ through $n$ and arranged in such a way that the entries are strictly increasing over the rows (from left to right) and columns (from top to bottom). Reading off the entries of the boxes, one may obtain the \textit{Yamanouchi} word by placing (in order) each character's index to the row corresponding to its lexicographical ordering.

In the case of $D^3$, the Tableau associated with these words is in fact \textit{rectangular} of size $n \times 3$, and the length of the corresponding word (called a \textit{balanced or dominant Yamanouchi word} in this context) is $3n$, where $n$ is the number of occurrences of each unique symbol\cite{moortgat}.
Practically, the rectangular shape ensures constraint (D1), while the ascending order of elements over rows and columns ensures constraint (D2). In that sense, a rectangular standard Young tableau of size $n \times 3$ is, as a construct, an alternative way of uniquely representing the different words of $D^3$. We present an example tableau in Fig.\ref{fig:tableau}.
\begin{figure}
	\centering
	\begin{tabular}{rl}
		\begin{tabular}{r}
		a: \\ b: \\ c:
		\end{tabular}
		&
      \begin{tabularx}{.4\linewidth}{YYYYYY}
      \rowcolor{Gray}
       1 & 3 & 4 & 8 & 9 & 10 \\
       \rowcolor{White}
	     2 &  5 &  7 &  11 & 13 & 15 \\
	    \rowcolor{Gray} 
	     6 &  12 &  14 &  16 & 17 & 18 \\
	    \end{tabularx}
	\end{tabular}
  	\caption{Young tableau for \w{abaabcbaaabcbcbccc}}
  	\label{fig:tableau}
\end{figure}

\paragraph{\textbf{Promotions and Orbits}}
There is an interesting transformation on Young Tableaux, namely the \textit{Jeu-de-taquin} algorithm. When operating on a rectangular tableau $T(n,3)$, Jeu-de-taquin consists of the following steps:
\begin{enumerate}
\item[(1)] Reduce all elements of T by 1 and replace the first item of the first row with an empty box $ \Box (x,y) := (1,1)$.
\item[(2)] While the empty box is not at the bottom right corner of T, $ \Box(x,y) \neq (n,3)$, do:
\begin{enumerate}
\item[-] Pick the minimum of the elements directly to the right and below the empty box, and swap the empty box with it. $ T(x, y) := min(T_{(x+1,y)}, T_{(x,y+1)})$, $ \Box (x',y') := (x+1, y)$ (in the case of a right-swap) or $\Box (x',y') := (x,y+1)$ (in the case of a down-swap).
\end{enumerate}
\item[(3)] Replace the empty box with $3n$.
\end{enumerate}

The tableau obtained through Jeu-de-taquin on T is called its promotion $p(T)$. We denote by $p^k(T)$, $k$ successive applications of Jeu-de-taquin. It has been proven that $p^{3n}(T)=T$\cite{petersen}. In other words, the promotion defines an equivalence class, which we name an \textit{orbit}, which cycles back to itself. Orbits dissect the space of $D^3$ into disjoint sets, i.e. every word $w$ belongs to a particular orbit, obtained by promotions of $T_w$.

\paragraph{\textbf{$\mathbf{A_2}$ Combinatorial Spider Webs}}
The $A_2$ \textit{irreducible combinatorial spider web} is a directed planar graph embedded in a disk that satisfies certain conditions\cite{kuperberg}. Spider webs can be obtained through the application of a set of rules, known as the \textit{Growth Algorithm}\cite{petersen}. These operate on pairs of neighbouring nodes, collapsing them into a singular intermediate node, transforming them into a new pair or eliminating them altogether. Growth rules will be examined from a grammatical perspective in Section \ref{subsec22}. Upon reaching a fixpoint, the growth process produces a well-formed Spider Web, which, in the context of $D^3$, can be interpreted as a visual representation of parsing a word\cite{moortgat,petersen}.

A bijection also links Young Tableaux with Spider Webs. More specifically, the act of promotion is isomorphic to a combinatorial action on spider webs, namely \textit{web rotation}\cite{petersen}.

\paragraph{\textbf{Constrained Walk}}
A Dyck word can also be visualized as a constrained \textit{walk} within the first quadrant of $\mathbb{Z}^2$. We can assign each alphabet symbol $x$ a vector value $\vec{v_x} \in \mathbb{Z}^2$ such that all pairs of $(\vec{v_x},\ \vec{v_y})$ are linearly independent and:
\begin{eqnarray}
\vec{v_a} + \vec{v_b} + \vec{v_c} &=& \vec{0} \\
\kappa\vec{v_a} + \lambda\vec{v_b} + \mu\vec{v_c} &\geq & \vec{0},  (\forall \kappa \geq \lambda \geq \mu)
\end{eqnarray}

We can then picture Dyck words as routes starting from $(0,0)$. (1) means that each route must also end at $(0,0)$ ($\cong$ (D1)), while (2) means that the $x$ and $y$ axes may never be crossed ($\cong$ (D2)). An example walk is depicted in Fig.\ref{fig:walk}.
\\
\begin{figure}
    \begin{center}
     \hspace{-2cm}
    \begin{tikzpicture}[
    	scale=1,
    	-->/.style={->,thick,shorten >=.666pt,shorten <=.666pt},
    ]
    \draw[loosely dotted] (0,0) grid (3,3);
    \path[use as bounding box] (-2,1) rectangle (3,3);
    \draw[->] (-0.25,0) -- (3.5,0) node[right] {$x$};
    \draw[->] (0,-0.25) -- (.,3.5) node[left] {$y$};
    \foreach \x/\xtext in {1/1, 2/2, 3/3}
    \draw[shift={(\x,0)}] (0pt,2pt) -- (0pt,-2pt) node[below] {$\xtext$};
    \foreach \y/\ytext in {1/1, 2/2, 3/3}
    \draw[shift={(0,\y)}] (2pt,0pt) -- (-2pt,0pt) node[left] {$\ytext$};
    \draw [bblue, -->] (0,0) -- node[left] {\tiny{(1)}} (0,1);
    \draw [rred, -->] (0,1) -- node[below] {\tiny{(2)}} (1,0);
    \draw [bblue, -->] (1,0) -- node[left] {\tiny{(3)}} (1,1);
    \draw [bblue, -->] (1,1) -- node[left] {\tiny{(4)}} (1,2);
	\draw [rred, -->] (1,2) -- node[below] {\tiny{(5)}} (2,1);
	\draw [rred, -->] (1,1) -- node[below] {\tiny{(7)}} (2,0);
	\draw [bblue, -->] (2,0) -- node[left] {\tiny{(8)}} (2,1);
    \draw [bblue, -->] (2,1) -- node[left] {\tiny{(9)}} (2,2);
    \draw [bblue, -->] (2,2) -- node[left] {\tiny{(10)}} (2,3);
    \draw [rred, -->] (2,3) -- node[below] {\tiny{(11)}}(3,2);
	\draw [ggreen, -->] (3,2) -- node[below] {\tiny{(12)}} (2,2);
	\draw [rred, -->] (2,2) -- node[below] {\tiny{(13)}} (3,1);
	\draw [ggreen, -->] (3,1) -- node[below] {\tiny{(14)}} (2,1);-
	\draw [ggreen, -->] (2,1) -- node[below] {\tiny{(6)}} (1,1);
    \draw [rred, -->] (2,1) -- node[below] {\tiny{(15)}} (3,0);
	\draw [ggreen, -->] (3,0) -- node[below] {\tiny{(16)}} (2,0);
	\draw [ggreen, -->] (2,0) -- node[below] {\tiny{(17)}} (1,0);
	\draw [ggreen, -->] (1,0) -- node[below] {\tiny{(18)}} (0,0);
    \draw[fill=orange,color=black] circle (0.75pt);
    \end{tikzpicture}    
    \end{center}
\caption{The constrained walk of \w{abaabcbaaabcbcbccc} with vector value assignments $\vec{v}_a = (1,0)$, $\vec{v}_b = (-1,1)$, $\vec{v}_c = (0,-1)$}
\label{fig:walk}
\end{figure}

\section{Modeling Techniques}\label{sec2}
We now present a number of novel techniques that we developed as an attempt to solve the problem at hand, incrementally moving towards more complex and abstract grammars. For the purpose of experimentation we have implemented these techniques, based on a software library for parsing MCFGs\cite{ljunglof}. The resulting Python code is open-source and available online\footnote{\url{https://github.com/omelkonian/dyck}}.

\subsection{Triple Insertion}
To set things off, we start with the grammar of \textit{triple insertion} in Fig.\ref{fig:ins}. This grammar operates on non-terminals $\s{W}(x,y)$, producing $\s{W}(x',y')$ with an additional triplet \textit{a, b, c} that respects the partial orders $x<y$ and $a<b<c$. The end-word is produced through the concatenation of $(x,y)$.

\begin{figure}
  \centering
  \begin{align}
	\setcounter{equation}{0}
	\s{S}(xy) \leftarrow \s{W}(x,y)&. \\
	\s{W}(\epsilon, xy\textbf{abc}) \leftarrow \s{W}(x,y)&. \\
	... \nonumber \\
	\setcounter{equation}{60}
	\s{W}(\textbf{abc}xy, \epsilon) \leftarrow \s{W}(x,y)&. \\
	\s{W}(\epsilon, \textbf{abc})&. \\
	... \nonumber \\
	\setcounter{equation}{64}
	\s{W}(\textbf{abc}, \epsilon)&.
	\end{align}
  \caption{Grammar of triple insertions}  
  \label{fig:ins}
\end{figure}

Despite being conceptually simple, this grammar consists of a large number of rules. Its expressivity is also limited; the prominent weak point is its inability to manage the effect of \textit{straddling}, namely the generation of words whose substituents display complex interleaving patterns. Refer to Fig.\ref{fig:fmp} for an example.
\subsection{Meta-Grammars}\label{subsec22}
To address the issue of rule size, we introduce the notion of \textit{meta-grammars}, loosely inspired by Van Wijngaarden's work\cite{vanwijn}, which allows a more abstract view of the grammar as a whole. Specifically, we define $\mathcal{O}$ as the \textit{meta-rule} which, given a rule format, a set of partial orders (over the tuple indices of its premises and/or newly added terminal symbols), and the MCFG dimensionality, automatically generates all the order-respecting permutations. An example of how we can abstract away from explicitly enumerating the entirety of our initial rules is showcased in Fig.\ref{fig:meta-ins}.

\begin{figure}
  \centering
  \begin{align*}
	&\s{S}(xy) \leftarrow \s{W}(x,y). \\
	&\Or{\s{W}}{\epsilon}{a < b < c}{2} \\
	&\Or{\s{W}}{\s{W}}{x < y,\ a < b < c}{2}
	\end{align*}
  \caption{$\mathcal{G}_0$: Meta-grammar of triple insertions}  
	\label{fig:meta-ins}
\end{figure}

This approach enhances the potential expressivity of our grammars as well. For instance, we can now extend the previous grammar with a single meta-rule that allows two non-terminals $\s{W}(x,y)$, $\s{W}(z,w)$ to interleave with one another, producing rearranged tuple concatenations and allowing some degree of straddling to be generated:
\[
\mathcal{G}_1: \mathcal{G}_0 + \Or{\s{W}}{\s{W}, \s{W}}{x < y,\ z < w}{2}
\]

The addition of this rule gets us closer to completeness, but we are still not quite there. We have thus far only used a single non-terminal, not utilizing the expressivity that an MCFG allows. To that end, we propose non-terminals to represent incomplete word \textit{states}; that is, words that either have an extra symbol or miss one. The former are \textit{positive} states, whereas the latter are \textit{negative}. The inclusion of these extra states would allow for more intricate interactions.

Interestingly, there is a direct correspondence between these non-terminals and the nodes of Petersen's growth algorithm\cite{petersen}. Fig.\ref{fig:rules} depicts the growth rules in the exact same web form as proposed by Petersen, modulo node branding. A subset of these web-reduction rules are, in fact, precisely modelled by the meta-grammar $\mathcal{G}_2$ presented in Fig.\ref{fig:g2}. In section \ref{sec4}, we briefly explain our inability to model the whole set of rules with a 2-MCFG, hence rendering our grammar complete.

\begin{figure}
\[
\begin{tikzpicture}[
every node/.style={anchor=base},xscale=.725,yscale=1,
-->/.style={->,shorten >=2pt,shorten <=2pt,>=stealth},
<--/.style={<-,shorten >=2pt,shorten <=2pt,>=stealth},
--->/.style={->,shorten >=1pt,shorten <=1pt,>=stealth},
<---/.style={<-,>=stealth},
]
\node (i1) at (0,0) {$\textsc{\small A}^+$};
\node (ii1) at (1,0) {$\textsc{\small B}^+$};
\node (d1) at (.5,-1) {};
\node (o1) at (.5,-2) {$\textsc{\small C}^-$};
\draw[-->] (i1) -- (d1.center);
\draw[-->] (ii1) -- (d1.center);
\draw[<--] (d1.north) -- (o1);

\node (i2) at (2,0) {$\textsc{\small B}^+$};
\node (ii2) at (3,0) {$\textsc{\small C}^+$};
\node (d2) at (2.5,-1) {};
\node (o2) at (2.5,-2) {$\textsc{\small A}^-$};
\draw[-->] (i2) -- (d2.center);
\draw[-->] (ii2) -- (d2.center);
\draw[<--] (d2.north) -- (o2);

\node (i3) at (4,0) {$\textsc{\small A}^+$};
\node (ii3) at (5,0) {$\textsc{\small C}^+$};
\node (d3) at (4.5,-1) {};
\node (o3) at (4.5,-2) {$\textsc{\small B}^-$};
\draw[-->] (i3) -- (d3.center);
\draw[-->] (ii3) -- (d3.center);
\draw[<--] (d3.north) -- (o3);

\node (i4) at (6,0) {$\textsc{\small B}^-$};
\node (ii4) at (7,0) {$\textsc{\small A}^-$};
\node (d4) at (6.5,-1) {};
\node (o4) at (6.5,-2) {$\textsc{\small C}^+$};
\draw[<-,>=stealth] (i4) -- (d4.center);
\draw[<-,>=stealth] (ii4) -- (d4.center);
\draw[->,>=stealth] (d4.center) -- (o4);

\node (i5) at (8,0) {$\textsc{\small C}^-$};
\node (ii5) at (9,0) {$\textsc{\small A}^-$};
\node (d5) at (8.5,-1) {};
\node (o5) at (8.5,-2) {$\textsc{\small B}^+$};
\draw[<-,>=stealth] (i5) -- (d5.center);
\draw[<-,>=stealth] (ii5) -- (d5.center);
\draw[->,>=stealth] (d5.center) -- (o5);

\node (i6) at (10,0) {$\textsc{\small C}^-$};
\node (ii6) at (11,0) {$\textsc{\small B}^-$};
\node (d6) at (10.5,-1) {};
\node (o6) at (10.5,-2) {$\textsc{\small A}^+$};
\draw[<-,>=stealth] (i6) -- (d6.center);
\draw[<-,>=stealth] (ii6) -- (d6.center);
\draw[->,>=stealth] (d6.center) -- (o6);

\node (i21) at (.5,-2.5) {$\textsc{\small B}^+$};
\node (ii21) at (2.5,-2.5) {$\textsc{\small B}^-$};
\node (d21) at (1,-3.5) {};
\node (dd21) at (2,-3.5) {};
\node (o21) at (.5,-4.5) {$\textsc{\small A}^-$};
\node (oo21) at (2.5,-4.5) {$\textsc{\small A}^-$};
\draw[->,>=stealth] (i21) -- (d21.center);
\draw[<-,>=stealth] (ii21) -- (dd21.center);
\draw[<-,>=stealth] (d21.center) -- (dd21.center);
\draw[<-,>=stealth, shorten >=5pt] (d21.center) -- (o21.center);
\draw[->,>=stealth, shorten >=5pt] (dd21.center) -- (oo21.center);

\node (i22) at (3.75,-2.5) {$\textsc{\small B}^+$};
\node (ii22) at (5.75,-2.5) {$\textsc{\small A}^-$};
\node (d22) at (4.25,-3.5) {};
\node (dd22) at (5.25,-3.5) {};
\node (o22) at (3.75,-4.5) {$\textsc{\small A}^-$};
\node (oo22) at (5.75,-4.5) {$\textsc{\small B}^+$};
\draw[->,>=stealth] (i22) -- (d22.center);
\draw[<-,>=stealth] (ii22) -- (dd22.center);
\draw[<-,>=stealth] (d22.center) -- (dd22.center);
\draw[<-,>=stealth, shorten >=5pt] (d22.center) -- (o22.center);
\draw[->,>=stealth, shorten >=5pt] (dd22.center) -- (oo22.center);

\node (i23) at (7,-2.5) {$\textsc{\small A}^+$};
\node (ii23) at (9,-2.5) {$\textsc{\small B}^-$};
\node (d23) at (7.5,-3.5) {};
\node (dd23) at (8.5,-3.5) {};
\node (o23) at (7,-4.5) {$\textsc{\small B}^-$};
\node (oo23) at (9,-4.5) {$\textsc{\small A}^+$};
\draw[->,>=stealth] (i23) -- (d23.center);
\draw[<-,>=stealth] (ii23) -- (dd23.center);
\draw[<-,>=stealth] (d23.center) -- (dd23.center);
\draw[<-,>=stealth, shorten >=5pt] (d23.center) -- (o23.center);
\draw[->,>=stealth, shorten >=5pt] (dd23.center) -- (oo23.center);

\node (i24) at (10,-2.5) {$\textsc{\small A}^+$};
\node (ii24) at (11,-2.5) {$\textsc{\small A}^-$};
\node (d24) at (10,-3.5) {};
\node (dd24) at (11,-3.5) {};
\draw[->,>=stealth] (i24) -- (d24.center);
\draw[<-,>=stealth] (ii24) -- (dd24.center);
\draw (d24.center) edge [-,>=stealth,bend right=90] (dd24.center);

\node (i31) at (.5,-5) {$\textsc{\small B}^-$};
\node (ii31) at (2.5,-5) {$\textsc{\small B}^+$};
\node (d31) at (1,-6) {};
\node (dd31) at (2,-6) {};
\node (o31) at (.5,-7) {$\textsc{\small C}^+$};
\node (oo31) at (2.5,-7) {$\textsc{\small C}^-$};
\draw[<-,>=stealth] (i31) -- (d31.center);
\draw[->,>=stealth] (ii31) -- (dd31.center);
\draw[->,>=stealth] (d31.center) -- (dd31.center);
\draw[->,>=stealth, shorten >=5pt] (d31.center) -- (o31.center);
\draw[<-,>=stealth, shorten >=5pt] (dd31.center) -- (oo31.center);

\node (i32) at (3.75,-5) {$\textsc{\small B}^-$};
\node (ii32) at (5.75,-5) {$\textsc{\small C}^+$};
\node (d32) at (4.25,-6) {};
\node (dd32) at (5.25,-6) {};
\node (o32) at (3.75,-7) {$\textsc{\small C}^+$};
\node (oo32) at (5.75,-7) {$\textsc{\small B}^-$};
\draw[<-,>=stealth] (i32) -- (d32.center);
\draw[->,>=stealth] (ii32) -- (dd32.center);
\draw[->,>=stealth] (d32.center) -- (dd32.center);
\draw[->,>=stealth, shorten >=5pt] (d32.center) -- (o32.center);
\draw[<-,>=stealth, shorten >=5pt] (dd32.center) -- (oo32.center);

\node (i33) at (7,-5) {$\textsc{\small C}^-$};
\node (ii33) at (9,-5) {$\textsc{\small B}^+$};
\node (d33) at (7.5,-6) {};
\node (dd33) at (8.5,-6) {};
\node (o33) at (7,-7) {$\textsc{\small B}^+$};
\node (oo33) at (9,-7) {$\textsc{\small C}^-$};
\draw[<-,>=stealth] (i33) -- (d33.center);
\draw[->,>=stealth] (ii33) -- (dd33.center);
\draw[->,>=stealth] (d33.center) -- (dd33.center);
\draw[->,>=stealth, shorten >=5pt] (d33.center) -- (o33.center);
\draw[<-,>=stealth, shorten >=5pt] (dd33.center) -- (oo33.center);

\node (i34) at (10,-5) {$\textsc{\small C}^-$};
\node (ii34) at (11,-5) {$\textsc{\small C}^+$};
\node (d34) at (10,-6) {};
\node (dd34) at (11,-6) {};\draw[<-,>=stealth] (i34) -- (d34.center);
\draw[->,>=stealth] (ii34) -- (dd34.center);
\draw (d34.center) edge [-,>=stealth,bend right=90] (dd34.center);

\end{tikzpicture}
\]
\caption{Growth rules}
\label{fig:rules}
\end{figure}

$\mathcal{G}_2$ consists of base cases for positive states, possible state interactions, closures of pairs of inverse polarity and a universally quantified meta-rule that allows the combination of any incomplete state with a well-formed one (i.e. non-terminal $\s{W}$).
\begin{figure}
    \centering
		\begin{minipage}{.2\textwidth}
		\begin{align*}
		&\s{S}(xy) \leftarrow \s{W}(x,y). \\
		&\Or{\s{W}}{\epsilon}{a < b < c}{2} \\
		&\Or{\s{A}^+}{\epsilon}{a}{2} \\
		&\Or{\s{B}^+}{\epsilon}{b}{2} \\
		&\Or{\s{C}^+}{\epsilon}{c}{2} \\
		&\Or{C^-}{A^+, B^+}{x < y < z < w}{2} \\
		&\Or{B^-}{A^+, C^+}{x < y < z < w}{2}
		\end{align*}
		\end{minipage}
~ ~ ~ ~ ~ ~
	    \begin{minipage}{.2\textwidth}
		\begin{align*}
		&\Or{A^-}{B^+, C^+}{x < y < z < w}{2} \\
		&\Or{A^+}{C^-, B^-}{x < y < z < w}{2} \\
		&\Or{B^+}{C^-, A^-}{x < y < z < w}{2} \\
		&\Or{C^+}{B^-, A^-}{x < y < z < w}{2} \\
		&\Or{W}{A^+, A^-}{x < y < z < w}{2} \\
		&\Or{W}{C^-, C^+}{x < y < z < w}{2} \\
		&\forall \ \s{K} \in \{\textsc{A}^{+/-},\ \textsc{B}^{+/-},\ \textsc{C}^{+/-}\}:\\ 
		&\quad\Or{\s{K}}{\s{K}, \s{W}}{x < y,\ z < w}{2}
		\end{align*}
		\end{minipage}
    \caption{$\mathcal{G}_2$: Meta-grammar of incomplete states}%
    \label{fig:g2}
\end{figure}

A further extension can be achieved through universally quantifying the notion of triple insertion, which is unique in the sense that it can insert three different terminals, each at a different position:
\[
\mathcal{G}_3: \mathcal{G}_2 + \forall \ \s{K} \in \{\textsc{A}^{+/-},\ \textsc{B}^{+/-},\ \textsc{C}^{+/-}\}: \Or{\s{K}}{\s{K}}{x < y,\ a < b < c}{2}
\]

\subsection{Rule Inference}\label{aris}	
The improved performance of the above approaches again proved insufficient to completely parse $D^3$. Our meta-rules are over-constrained by imposing a total order on the tuple elements, due to their inability to keep track of where the extra character(s) is. To overcome this, we split each state into multiple position-aware, \textit{refined} states. Doing so revealed a vast amount of new interactions, as evidenced by the below alteration to the original $\s{A}^+$, $\s{B}^+$ interaction (where $y$ can now occur after $z$ or $w$):
\[
\Or{C^-}{A^+_{left}, B^+}{x < y, x < z < w}{2}
\]

In order to accommodate the interactions between this increased number of states, we need to keep track of both internal and external order constraints. At this point, the abstraction offered by our meta-grammar approach does not cover our needs any more. The same difficulty that we had encountered before is prominent once more, except now at an even higher level. 

As a solution to the aforementioned limitation, we propose a system that can automatically create a full-blown m-MCFG given only the states it consists of. To accomplish this, we assign each state a unique \textit{descriptor} that specifies the content of its tuple's elements. Aligning these descriptors with the tuple, we can then infer the descriptor of the resulting tuple of every possible state interaction. For the subset of those interactions whose resulting descriptor is matched with a state, we can now automatically infer the rule.

Formally, the system is initialized with a map $\mathcal{D}$, such as the one illustrated in Fig.\ref{fig:desc}. Its domain, $dom(\mathcal{D})$, is a set of \textit{state identifiers} and its codomain, $codom(\mathcal{D})$, is the set of their corresponding \textit{state descriptors}.

\begin{figure}
\begin{align*}
\s{W} &\mapsto (\epsilon, \epsilon) \\
\s{A}^+_{l} &\mapsto (a, \epsilon) \\
\s{A}^+_{r} &\mapsto (\epsilon, a) \\
&\quad \vdots \\
\s{C}^-_{r} &\mapsto (\epsilon, ab) \\
\s{C}^-_{l, r} &\mapsto (a, b)
\end{align*}
\caption{Map $\mathcal{D}$ for refined states}
\label{fig:desc}
\end{figure}

\begin{algorithm}[H]
\caption{ARIS: Automatic Rule Inference System}\label{euclid}
\begin{algorithmic}
\Procedure{aris}{$\mathcal{D}$}
	\For{$X \mapsto (d_1,\dots ,d_n) \in \mathcal{D}$}
		\State \textbf{yield} $X(d_1,\dots,d_n).$
	\EndFor
	\For{$X,Y \in dom(\mathcal{D})^2$}
		\State $(X_{ord},\ Y_{ord}) \leftarrow (x<y<\dots,\ z<w<\dots)$ 
		\For{$(d_1,...,d_n) \in \Orr{\_}{X,Y}{X_{ord}, Y_{ord}}{2}$}
			\For{$S' \in \textsc{eliminate}((d_1,\dots ,d_n), \mathcal{D})$}
				\State \textbf{yield} $S'(d_1,\dots ,d_n) \leftarrow X, Y.$
			\EndFor
		\EndFor
	\EndFor
\EndProcedure
\\
\Procedure{eliminate}{$(d_1,\dots ,d_n), \mathcal{D}$}
	\For{$matches \in \textsc{all\_abc\_triplets}(d_1,\dots ,d_n)$}
		\For{$i \in 0\dots n/3$}
			\For{$S' \in \textsc{remove\_abc\_triplets}(matches, i)$}
				\If {$S' \in codom(\mathcal{D})$}
					\State \textbf{yield} $S'$
				\EndIf				
			\EndFor
		\EndFor
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

Meta-grammars accelerated the process of creating grammars, by letting us simply describe rules instead of explicitly defining them. ARIS builds upon this notion to raise the level of abstraction even further; one needs only specify a grammar's states and its descriptors, thus eliminating the need to define rules or even meta-rules.

\section{Tools \& Results}
\subsection{Grammar Utilities}
We have implemented the modelling techniques described in Section \ref{sec2} and distributed a Python package, called \textbf{dyck}, which provides the programmer with a \textit{domain-specific language} close to this paper's mathematical notation. To facilitate experimentation, our package includes features such as grammar selection, time measurements, word generation and soundness/completeness checking. The following example demonstrates the definition of $\mathcal{G}_1$:

\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{minted}[baselinestretch=1.1, fontsize=\small]{python}
from dyck import *
G_1 = Grammar([
    ('S <- W', {(x, y)}),
    O('W', {(a, b, c)}),
    O('W <- W', {(x, y), (a, b, c)}),
    O('W <- W, W', {(x, y), (z, w)}) 
])
\end{minted}
\end{minipage}
\end{center}

\subsection{Visualization}
As counter-examples began to grow in size and number, we realised the necessity of a visualization tool to assist us in identifying properties they may exhibit. To that end, we distribute another Python package, called \textbf{dyckviz}, which allows the simultaneous visualization of tableau-promotion and web-rotation (grouped in their corresponding equivalence classes). An example of a web as rendered by our tool is given in Fig.\ref{fig:web}.

Young tableaux in an orbit are colour-grouped by their column indices, which sheds some light on how the \textit{jeu-de-taquin} actually influences the structure of the corresponding Dyck words. Interesting patterns have began to emerge, which still remain to be properly investigated. 

\begin{figure}
\begin{center}
\includegraphics[width=.75\textwidth]{web.pdf}
\caption{Spider web of \w{abaacbbacbabaccbcc}}
\label{fig:web}
\end{center}
\end{figure}

\subsection{Grammar Comparisons}
Fig.\ref{fig:charts} displays three charts, depicting the number of rules, percentage of counter-examples and computation times of each of our grammars for $D^3_n$ with $n$ ranging from $2$ to $6$ (where $n$ denotes the number of $abc$ triplets). Even though none of our proposed grammars is complete, we observe that as grammars get more abstract, the number of failing parses steadily declines. This however comes at the cost of rule size growth, which in turn is associated with an increase in computation times. What this practically means is that we are unable to continue testing more elaborate grammars or scale our results to higher orders of $n$ (note that $| \! | D^3_n | \! |$ also has a very rapid rate of expansion\footnote{\url{https://oeis.org/A000108}}).
\begin{figure}[h]
% Rule size
\begin{tikzpicture}
    \begin{axis}[
        width  = 0.45\textwidth,
        height = 4.2cm,
        major x tick style = transparent,
        ybar=20,
        bar width=4.5pt,
        ymajorgrids = true,
        ylabel = {\textsc{Rule size}},
        every axis x label/.style={
  			  at={(ticklabel* cs:1.05)},
  			  anchor=west,
  			  },
			every axis y label/.style={at={(current axis.north)},above=1mm},
        symbolic x coords={$ $},
        xtick = data,
        scaled y ticks = false,
        enlarge x limits=0.5,
        ymin=0,
        legend cell align=left,
        legend style={
        		at={(0.5,-0.15)},
				anchor=north,
				legend columns=-1
			},
    ]
        \addplot[style={bblue,fill=bblue,mark=none}]
            coordinates {($ $, 65)};
        \addplot[style={rred,fill=rred,mark=none}]
             coordinates {($ $,95)};
        \addplot[style={ggreen,fill=ggreen,mark=none}]
             coordinates {($ $,270)};
        \addplot[style={ppurple,fill=ppurple,mark=none}]
             coordinates {($ $,690)};
        \addplot[style={pyellow,fill=pyellow,mark=none}]
             coordinates {($ $,1456)};
    \end{axis}
\end{tikzpicture}
% Computation Time
~ ~ ~ ~ ~ ~ ~
\begin{tikzpicture}
    \begin{axis}[
        width  = 0.55*\textwidth,
        height = 4cm,
        major x tick style = transparent,
        ybar=5*\pgflinewidth,
        bar width=3pt,
        ymajorgrids = true,
        ylabel = {\textsc{Computation Time} \tiny log(sec)},
        every axis x label/.style={
  			  at={(ticklabel* cs:1.05)},
  			  anchor=west,
  			  },
			every axis y label/.style={at={(current axis.north)},above=1mm},
        symbolic x coords={$n=2$,$n=3$,$n=4$,$n=5$,$n=6$},
        xtick = data,
        scaled y ticks = false,
        enlarge x limits=0.1,
        ymin=0,
        legend cell align=left,
        legend style={
        		at={(0.5,-0.25)},
				anchor=north,
				legend columns=-1
			},
		ytick={0, 1, ..., 5},
		y grid style={densely dotted, line cap=round},
    ]
		 \addplot[style={bblue,fill=bblue,mark=none}]
           coordinates {($n=2$, 0) ($n=3$,-0.3) ($n=4$,0.9) ($n=5$,2.1) ($n=6$,3.37)};           
        \addplot[style={rred,fill=rred,mark=none}]
             coordinates {($n=2$,0) ($n=3$,0) ($n=4$,1.23) ($n=5$,2.39) ($n=6$,3.73)};             
        \addplot[style={ggreen,fill=ggreen,mark=none}]
             coordinates {($n=2$,0) ($n=3$,1) ($n=4$,2.28) ($n=5$,3.54) ($n=6$,4.79)};
        \addplot[style={ppurple,fill=ppurple,mark=none}]
             coordinates {($n=2$,0) ($n=3$,1.04) ($n=4$,2.34) ($n=5$,3.64) ($n=6$,4.99)};
        \addplot[style={pyellow,fill=pyellow,mark=none}]
             coordinates {($n=2$,0.17) ($n=3$,1.46) ($n=4$,2.77) ($n=5$,4.09) ($n=6$,5.42)};
    \end{axis}
\end{tikzpicture}
% Counter-examples
\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        width  = 1*\textwidth,
        height = 4.5cm,
        major x tick style = transparent,
        ybar=4*\pgflinewidth,
        bar width=3pt,
        ymajorgrids = true,
        ylabel = {\textsc{Counter-examples} \small (\%)},
        every axis x label/.style={
  			  at={(ticklabel* cs:1.05)},
  			  anchor=west,
  			  },
			every axis y label/.style={at={(current axis.north)},above=1mm},
        symbolic x coords={$n=2$,$n=3$,$n=4$,$n=5$,$n=6$},
        xtick = data,
        scaled y ticks = false,
        enlarge x limits=0.1,
        ymin=0,
        legend cell align=left,
        legend style={
        		at={(0.5,-0.27)},
				anchor=north,
				legend columns=-1
			},
		ytick={0, 2, ..., 17},
		y grid style={densely dotted, line cap=round},
    ]
        \addplot[style={bblue,fill=bblue,mark=none}]
            coordinates {($n=2$, 0) ($n=3$,0) ($n=4$,1.7) ($n=5$,6.42) ($n=6$,14.55)};
        \addplot[style={rred,fill=rred,mark=none}]
             coordinates {($n=2$,0) ($n=3$,0) ($n=4$,1.5) ($n=5$,5) ($n=6$,10)};
        \addplot[style={ggreen,fill=ggreen,mark=none}]
             coordinates {($n=2$,0) ($n=3$,0) ($n=4$,0.2) ($n=5$,0.8) ($n=6$,1.7)};
        \addplot[style={ppurple,fill=ppurple,mark=none}]
             coordinates {($n=2$,0) ($n=3$,0) ($n=4$,0) ($n=5$,0) ($n=6$,0.3)};
        \addplot[style={pyellow,fill=pyellow,mark=none}]
             coordinates {($n=2$,0) ($n=3$,0) ($n=4$,0) ($n=5$,0) ($n=6$,0.15)};
        \legend{G$_0$,G$_1$,G$_2$,G$_3$,G$_4$,G$_5$}
    \end{axis}
\end{tikzpicture}
\end{center}
\caption{Performance measures}
\label{fig:charts}
\end{figure}

\section{Road to Completeness}\label{sec4}
To our knowledge, no other attempt has come so close to modelling $D^3$ with a 2-MCFG. We attribute this to the combination of a pragmatic approach with results from existing theoretical work. In this section, we present a collection of additional ideas, which we consider worthy of further exploration.

\paragraph{\textbf{First-Match Policy and Relinking}}
Possibly the most intuitive way of checking whether a word $w$ is part of $D^3_n$ is checking whether a pair of links occur that match $a_i$ to $b_i$ and $b_i$ to $c_i \ \forall i \in n$. We call this process of matching the \textit{first-match policy}. The question arises whether a grammar can accomplish inserting a triplet of $a$, $b$, $c$, that would abide by the first-match policy. If that were the case, it would be relatively easy to generalize this ability by induction to every $n \in \mathbb{N}$. Unfortunately, the answer is seemingly negative; the expressiveness provided by a 2-MCFG does not allow for the arbitrary insertions required. On a related note, being able to produce a word state $W(x,y)$ where $w=xy$ and $x$ any possible prefix of $w$, gives no guarantee of being able to produce the same word with an extra triplet inserted due to the straddling property. 

However, if rules existed that would allow for match-making and breaking, i.e. match \textit{relinking}, an inserted symbol could be temporarily matched with what might be its first match-policy in a local scope, and then relink it to its correct match when merging two words together.
\begin{figure}[h]
\centering
\begin{tikzpicture}[every node/.style={anchor=base},xscale=.25,yscale=.4]
\node (n0) at (0,0) {$a$};
\node (n1) at (1,0) {$b$};
\node (n2) at (2,0) {$a$};
\node (n3) at (3,0) {$b$};
\node (n4) at (4,0) {$a$};
\node (n5) at (5,0) {$c$};
\node (n6) at (6,0) {$b$};
\node (n7) at (7,0) {$c$};
\node (n8) at (8,0) {$a$};
\node (n9) at (9,0) {$b$};
\node (n10) at (10,0) {$c$};
\node (n11) at (11,0) {$c$};
\draw (n0) edge [rred, bend left=90] (n1);
\draw (n1) edge [rred, bend right=90] (n5);
\draw (n2) edge [ggreen, bend left=90] (n3);
\draw (n3) edge [ggreen, bend right=90] (n7);
\draw (n4) edge [bblue, bend left=90] (n6);
\draw (n6) edge [bblue, bend right=90] (n10);
\draw (n8) edge [pyellow, bend left=90] (n9);
\draw (n9) edge [pyellow, bend right=90] (n11);
\end{tikzpicture}
\caption{First-match policy for \w{ababacbcabcc}}
\label{fig:fmp}
\end{figure}
\paragraph{\textbf{Growth Rules}}
Although $\mathcal{G}_2$ comes close to realizing the growth algorithm, not all of the growth rules can be translated into a 2-MCFG setting. It would be an interesting endeavour to attempt to model the element-swapping behaviour of these rules that produce two output states, without resorting to more expressive formalisms (e.g. context-sensitive grammars).
\paragraph{\textbf{Insights from promotion}}
An interesting question is whether promotion can be handled by a 2-MCFG (as a \textit{context-free rewriting system}). If so, it could be worth looking into the properties of orbits, to test for instance if there are promotions within an orbit that can be easier to solve than others. Solving a single promotion and transducing the solution to all equivalent words could then be a guideline towards completeness. 

\section{Conclusion}
We tried to accurately present the intricacies of $D^3$ and the difficulties that arise when attempting to model it as a 2-MCFL. We have developed and introduced some novel techniques and tools, which we believe can be of use even outside the problem's narrow domain. We have largely expanded on the existing tools to accommodate MIX-style languages and systems of meta-grammars in general.

Despite our best efforts, the question of whether $D^3$ can actually be encapsulated within a 2-MCFG still remains unanswered. Regardless, this problem has been very rewarding to pursue, and we hope to have intrigued the interested reader enough to further research the subject, use our code, or strive for a solution on her own.

\section*{Acknowledgements}
We would like to thank Dr. Michael Moortgat for introducing us to the problem, providing insightful feedback and motivating us throughout the process, as well as Dr. Jurriaan Hage for suggesting the use of multi-dimensional Dyck languages in static analysis.

% Bibliography
\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\providecommand{\doi}[1]{https://doi.org/#1}

\bibitem{andreas}
Chatterjee, K., Choudhary, B., Pavlogiannis, A.: Optimal dyck reachability for
  data-dependence and alias analysis. Proceedings of the ACM on Programming
  Languages  \textbf{2}(POPL), ~30 (2017)

\bibitem{gotzmann}
G{\"o}tzmann, D.N.: Multiple context-free grammars

\bibitem{kanazawa}
Kanazawa, M., Salvati, S.: Mix is not a tree-adjoining language. In:
  Proceedings of the 50th Annual Meeting of the Association for Computational
  Linguistics: Long Papers-Volume 1. pp. 666--674. Association for
  Computational Linguistics (2012)

\bibitem{kuperberg}
Kuperberg, G.: Spiders for rank 2 lie algebras. Communications in mathematical
  physics  \textbf{180}(1),  109--151 (1996)

\bibitem{ljunglof}
Ljungl{\"o}f, P.: Practical parsing of parallel multiple context-free grammars.
  In: Workshop on Tree Adjoining Grammars and Related Formalisms. p.~144 (2012)

\bibitem{moortgat}
Moortgat, M.: A note on multidimensional dyck languages. In: Categories and
  Types in Logic, Language, and Physics. pp. 279--296 (2014)

\bibitem{petersen}
Petersen, T.K., Pylyavskyy, P., Rhoades, B.: Promotion and cyclic sieving via
  webs. Journal of Algebraic Combinatorics  \textbf{30}(1),  19--41 (2009)

\bibitem{reps2}
Reps, T., Horwitz, S., Sagiv, M.: Precise interprocedural dataflow analysis via
  graph reachability. pp. 49--61. ACM (1995)

\bibitem{reps}
Reps, T.W.: Program analysis via graph reachability. In: Logic Programming,
  Proceedings of the 1997 International Symposium, Port Jefferson, Long Island,
  NY, USA, October 13-16, 1997. pp. 5--19 (1997)

\bibitem{salvati}
Salvati, S.: Mix is a 2-mcfl and the word problem in $z^2$ is solved by a
  third-order collapsible pushdown automaton. Journal of Computer and System
  Sciences  \textbf{81}(7),  1252--1277 (2015)

\bibitem{vanwijn}
van Wijngaarden, A.: The generative power of two-level grammars. In: ICALP
  (1974)

\end{thebibliography}

\end{document}

